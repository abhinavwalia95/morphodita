MorphoDiTa API Reference


%!encoding: utf-8

The MorphoDiTa API is defined in header ``morphodita.h`` and resides in
``ufal::morphodita`` namespace.

The strings used in the MorphoDiTa API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).

++ Struct string_piece ++[string_piece]
```
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string& str);
}
```

The [``string_piece`` #string_piece] is used for efficient string passing. The string
referenced in [``string_piece`` #string_piece] is not owned by it, so users have to make sure
the referenced string exists as long as the [``string_piece`` #string_piece].

++ Struct tagged_form ++[tagged_form]
```
struct tagged_form {
  std::string form;
  std::string tag;
};
```

The [``tagged_form`` #tagged_form] is a pair of strings used when obtaining a form and tag
pair.

++ Struct tagged_lemma ++[tagged_lemma]
```
struct tagged_lemma {
  std::string lemma;
  std::string tag;
};
```

The [``tagged_lemma`` #tagged_lemma] is a pair of strings used when obtaining a lemma and tag
pair.

++ Struct tagged_lemma_forms ++[tagged_lemma_forms]
```
struct tagged_lemma_forms {
  std::string lemma;
  std::vector<[tagged_form #tagged_form]> forms;
};
```

The [``tagged_lemma_forms`` #tagged_lemma_forms] represents a lemma and a list of tagged forms.

++ Struct token_range ++[token_range]
```
struct token_range {
  size_t start;
  size_t length;
};
```

The [``token_range`` #token_range] represent a range of a token as returned by a [tokenizer #tokenizer].
The ``start`` and ``length`` fields specify the token position in Unicode
characters, not in bytes of UTF-8 encoding.

++ Class tokenizer ++[tokenizer]
```
class tokenizer {
 public:
  virtual ~tokenizer() {}

  virtual void [set_text #tokenizer_set_text](const char* text) = 0;

  virtual bool [next_sentence #tokenizer_next_sentence](std::vector<[string_piece #string_piece]>* forms, std::vector<[token_range #token_range]>* tokens) = 0;
};
```

The [``tokenizer`` #tokenizer] class performs segmentation and tokenization of given text.
The class is //not// threadsafe.

+++ tokenizer::set_text +++[tokenizer_set_text]
``` virtual void set_text(const char* text) = 0;

Set the text which is to be tokenized. Only a reference to the given text is
stored, therefore, the users have to make sure it exists as long as the tokenizer
is destructed or ``set_text`` is called again.

+++ tokenizer::next_sentence +++[tokenizer_next_sentence]
``` virtual bool next_sentence(std::vector<[string_piece #string_piece]>* forms, std::vector<[token_range #token_range]>* tokens) = 0;

Locate and return next sentence of the given text. Returns ``true`` when successful and ``false`` when
there are no more sentences in the given text. The arguments are filled with found tokens if not ``NULL``.
The ``forms`` contain token ranges in bytes of UTF-8 encoding, the ``tokens`` contain token ranges
in Unicode characters.


++ Class morpho ++[morpho]
```
class morpho {
 public:
  virtual ~morpho() {}

  static [morpho #morpho]* [load #morpho_load_cstring](const char* fname);
  static [morpho #morpho]* [load #morpho_load_FILE](FILE* f);

  enum [guesser_mode #morpho_guesser_mode] { NO_GUESSER = 0, GUESSER = 1 };

  virtual int [analyze #morpho_analyze]([string_piece #string_piece] form, [guesser_mode #morpho_guesser_mode] guesser, std::vector<[tagged_lemma #tagged_lemma]>& lemmas) const = 0;
  virtual int [generate #morpho_generate]([string_piece #string_piece] lemma, const char* tag_wildcard, [guesser_mode #morpho_guesser_mode] guesser,
                       std::vector<[tagged_lemma_forms #tagged_lemma_forms]>& forms) const = 0;

  virtual int [raw_lemma_len #morpho_raw_lemma_len]([string_piece #string_piece] lemma) const = 0;
  virtual int [lemma_id_len #morpho_lemma_id_len]([string_piece #string_piece] lemma) const = 0;

  virtual [tokenizer #tokenizer]* [new_tokenizer #morpho_new_tokenizer]() const = 0;
};
```

A [``morpho`` #morpho] instance represents a morphologic dictionary. Such a dictionary allow
morphologic analysis, morphologic generation provide information about lemma structure
and provides a suitable tokenizer. All methods are thread-safe.

+++ morpho::load(const char*) +++[morpho_load_cstring]
``` static [morpho #morpho]* load(const char* fname);

Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of [``morpho`` #morpho] which the user should delete
after use.

+++ morpho::load(FILE*) +++[morpho_load_FILE]
``` static [morpho #morpho]* load(FILE* f);

Factory method constructor. Accepts C file pointer of an opened file with the
model. Returns a pointer to an instance of [``morpho`` #morpho] which the user should
delete after use.

+++ morpho::guesser_mode +++[morpho_guesser_mode]
``` enum [guesser_mode #morpho_guesser_mode] { NO_GUESSER = 0, GUESSER = 1 };

Guesser mode defines behavior in case of unknown words. When set to
``GUESSER``, morpho tries to guess unknown words. When set to ``NO_GUESSER``,
morpho does not guess unknown words.

+++ morpho::analyze() +++[morpho_analyze]
``` virtual int analyze([string_piece #string_piece] form, [guesser_mode #morpho_guesser_mode] guesser, std::vector<[tagged_lemma #tagged_lemma]>& lemmas) const = 0;

Perform morphologic analysis of a form. The guesser parameter specifies whether
a guesser can be used if the form is not found in the dictionary. Output is
assigned to the lemmas vector.

If the form is found in the dictionary, analyses are assigned to lemmas
and ``NO_GUESSER`` returned. If ``guesser == GUESSER`` and the form analyses are
found using a guesser, they are assigned to lemmas and ``GUESSER`` is
returned.  Otherwise ``-1`` is returned and lemmas are filled with one
analysis containing given form as lemma and a tag for unknown word.

+++ morpho::generate() +++[morpho_generate]
```
virtual int generate([string_piece #string_piece] lemmma, const char* tag_wildcard, [guesser_mode #morpho_guesser_mode] guesser,
                     std::vector<[tagged_lemma_forms #tagged_lemma_forms]>& forms) const = 0;
```

Perform morphologic generation of a lemma. Optionally a tag_wildcard can be
specified (or be ``NULL``) and if so, results are filtered using this wildcard.
The guesser parameter speficies whether a guesser can be used if the lemma is
not found in the dictionary. Output is assigned to the forms vector.

Tag_wildcard can be either ``NULL`` or a wildcard applied to the results.
A ``?`` in the wildcard matches any character, ``[bytes]`` matches any of the
bytes and ``[^bytes]`` matches any byte different from the specified ones.
A ``-`` has no special meaning inside the bytes and if ``]`` is first in bytes,
it does not end the bytes group.

If the given lemma is only a raw lemma, all lemma ids with this raw lemma are
returned. Otherwise only matching lemma ids are returned, ignoring any lemma
comments. For every found lemma, matching forms are filtered using the
tag_wildcard. If at least one lemma is found in the dictionary, ``NO_GUESSER``
is returned. If ``guesser == GUESSER`` and the lemma is found by the guesser,
``GUESSER`` is returned. Otherwise, forms are cleared and ``-1`` is returned.

+++ morpho::raw_lemma_len +++[morpho_raw_lemma_len]
``` virtual int raw_lemma_len([string_piece #string_piece] lemma) const = 0;

When given a lemma returned by the dictionary, returns the length of
a raw lemma (text form of the lemma).

+++ morpho::lemma_id_len +++[morpho_lemma_id_len]
``` virtual int lemma_id_len([string_piece #string_piece] lemma) const = 0;

When given a lemma returned by the dictionary, returns the length of
a unique lemma identification. The rest of the lemma are comments which
do not identificate the lemma.

+++ morpho::new_tokenizer +++[morpho_new_tokenizer]
``` virtual [tokenizer #tokenizer]* new_tokenizer() const = 0;

Returns a new instance of a suitable tokenizer. The user should delete it after
use.

++ Class tagger ++[tagger]

```
class tagger {
 public:
  virtual ~tagger() {}

  static [tagger #tagger]* [load #tagger_load_cstring](const char* fname);
  static [tagger #tagger]* [load #tagger_load_FILE](FILE* f);

  virtual const [morpho #morpho]* [get_morpho #tagger_get_morpho]() const = 0;

  virtual void [tag #tagger_tag](const std::vector<[string_piece #string_piece]>& forms, std::vector<[tagged_lemma #tagged_lemma]>& tags) const = 0;
  void [tokenize_and_tag #tagger_tokenize_and_tag](const char* text, std::vector<[tagged_lemma #tagged_lemma]>& tags,
                        std::vector<[string_piece #string_piece]>* forms, std::vector<[token_range #token_range]>* tokens) const;
};
```

A [``tagger`` #tagger] instance represents a tagger, which perform disambiguation of
morphologic analyses. All methods are thread-safe.

+++ tagger::load(const char*) +++[tagger_load_cstring]
``` static [tagger #tagger]* load(const char* fname);

Factory method constructor. Accepts C string with a file name of the model.
Returns a pointer to an instance of [``tagger`` #tagger] which the user should delete
after use.


+++ tagger::load(FILE*) +++[tagger_load_FILE]
``` static [tagger #tagger]* load(FILE* f);

Factory method constructor. Accepts C file pointer of an opened file with the
model. Returns a pointer to an instance of [``tagger`` #tagger] which the user should
delete after use.

+++ tagger::get_morpho() +++[tagger_get_morpho]
``` virtual const [morpho #morpho]* get_morpho() const = 0;

Returns a pointer to an instance of [``morpho`` #morpho] associated with the tagger. Do
not delete the pointer, it is owned by the tagger instance and deleted in the
tagger destructor.

+++ tagger::tag() +++[tagger_tag]
``` virtual void tag(const std::vector<[string_piece #string_piece]>& forms, std::vector<[tagged_lemma #tagged_lemma]>& tags) const = 0;

Perform morphologic analysis and subsequent disambiguation. Accepts
a ``std::vector`` of [``string_piece`` #string_piece] and fills the output vector of [``tagged_lemma`` #tagged_lemma].

+++ tagger::tokenize_and_tag() +++[tagger_tokenize_and_tag]
```
void tokenize_and_tag(const char* text, std::vector<[tagged_lemma #tagged_lemma]>& tags,
                      std::vector<[string_piece #string_piece]>* forms, std::vector<[token_range #token_range]>* tokens) const;
```

Perform tokenization and morphologic analysis and subsequent disambiguation. The arguments
``forms`` and ``tokens`` are the same as in [``tokenizer::next_sentence`` #tokenizer_next_sentence].
