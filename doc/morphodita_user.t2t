MorphoDiTa User's Manual
========================

%!encoding: utf-8

In a natural language text, the task of morphological analysis is to assign for
each token (word) in a sentence its lemma (cannonical form) and
a part-of-speech tag (POS tag). This is usually achieved in two steps:
a morphological dictionary looks up all possible lemmas and POS tags for each
word, and subsequently, a morphological tagger picks for each word the best
lemma-POS tag candidate. The second task is called a disambiguation.

MorphoDiTa also performs these two steps of morphological analysis: It first
outputs all possible pairs of lemma and POS tag for each token. Consequently,
the optimal combination of lemmas and POS tags is selected for the words in
a sentence using an algorithm described in
[Spoustová et al. 2009 http://aclweb.org/anthology//E/E09/E09-1087.pdf].

Like any supervised machine learning tool, MorphoDiTa needs a trained linguistic model.
This section describes the available language models and also the commandline
tools and interfaces. The C++ library is described elsewhere, either in
MorphoDiTa API Tutorial or in MorphoDiTa API Reference.


%!include: morphodita_model_czech-morfflex-pdt.t2t


%!include: morphodita_model_english-morphium-wsj.t2t


== Running the Tagger ==[run_tagger]

Probably the most common usage of MorphoDita is running a tagger to tag your data using
``` run_tagger tagger_model

The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically.

Any number of files can be specified after the ``tagger_model``. If an argument
``input_file:output_file`` is used, the given ``input_file`` is processed and
the result is saved to ``output_file``. If only ``input_file`` is used, the
result is saved to standard output. If no argument is given, input is read
from standard input and written to standard output.

The full command syntax of ``run_tagger`` is
```
run_tagger [options] tagger_file [file[:output_file]]...
Options: --input=untokenized|vertical
         --convert_tagset=pdt_to_conll2009
         --output=vertical|xml
```

=== Input Formats ===

The input format is specified using the ``--input`` option. Currently supported
input formats are:
- ``untokenized`` (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
- ``vertical``: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.


=== Tag Set Conversion ===

Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
- ``pdt_to_conll2009``: convert Czech PDT tag set to CoNLL 2009 tag set.


=== Output Formats ===

The output format is specified using the ``--output`` option. Currently
supported output formats are:
- ``xml`` (default): Simple XML format without a root element, using
  ``<sentence>`` element to mark sentences and
  ``<token lemma="..." tag="...">...</token>`` element to encode token
  and its assigned lemma and tag.

  Example output for input ``Děti pojedou k babičce. Už se těší.`` (line breaks added):
```
<sentence><token lemma='dítě' tag='NNFP1-----A----'>Děti</token>
<token lemma='jet-1_^(pohybovat_se,_ne_však_chůzí)' tag='VB-P---3F-AA---'>pojedou</token>
<token lemma='k-1' tag='RR--3----------'>k</token>
<token lemma='babička' tag='NNFS3-----A----'>babičce</token>
<token lemma='.' tag='Z:-------------'>.</token></sentence>
<sentence><token lemma='už-1' tag='Db-------------'>Už</token>
<token lemma='se_^(zvr._zájmeno/částice)' tag='P7-X4----------'>se</token>
<token lemma='těšit_:T' tag='VB-S---3P-AA---'>těší</token>
<token lemma='.' tag='Z:-------------'>.</token></sentence>
```

- ``vertical``: Every output line is a tag separated triple form-lemma-tag, with empty
  line denoting end of sentence.

  Example output for input ``Děti pojedou k babičce. Už se těší.``:
```
Děti	dítě	NNFP1-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------
babičce	babička	NNFS3-----A----
.	.	Z:-------------

Už	už-1	Db-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------
těší	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
```


== Running the Morphology ==

There are multiple commands performing morphological tasks.
The [``run_morpho_analyze`` #run_morpho_analyze] executable performs morphological analysis and
the [``run_morpho_generate`` #run_morpho_generate] executable performs morphological generation.
The output of these commands is suitable for automatic processing.

The [``run_morpho_cli`` #run_morpho_cli] executable performs both morphological analysis and generation,
but is designed to be used interactively and produces more human-readable output.

=== Morphological Analysis ===[run_morpho_analyze]

The morphological analysis can be performed by running
``` run_morpho_analyze morphology_model use_guesser

The input is assumed to be in UTF-8 encoding and can be either already
tokenized and segmented, or it can be a plain text which is tokenized and
segmented automatically. The input files are specified same as with the
[``run_tagger`` #run_tagger] command.

Some morphological models contain both a manually created dictionary and
a guesser. Therefore, a numeric ``use_guesser`` argument is required.
If non-zero, the guesser is used, otherwise not.

The full command syntax of ``run_morpho_analyze`` is
```
run_morpho_analyze [options] morphology_model use_guesser [file[:output_file]]...
Options: --input=untokenized|vertical
         --convert_tagset=pdt_to_conll2009
         --output=vertical|xml
```

==== Input Formats ====

The input format is specified using the ``--input`` option. Currently supported
input formats are:
- ``untokenized`` (default): the input is tokenized and segmented using
  a tokenizer defined by the model,
- ``vertical``: the input is in vertical format, every line is considered
  a word, with empty line denoting end of sentence.


Note that the input data is also segmented, even if it is not strictly
necessary. Therefore, the input is processed by whole paragraphs (ending
by an empty line).

==== Tag Set Conversion ====

Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
- ``pdt_to_conll2009``: convert Czech PDT tag set to CoNLL 2009 tag set.


==== Output Formats ====

The output format is specified using the ``--output`` option. Currently
supported output formats are:
- ``xml`` (default): Simple XML format without a root element, using
  using ``<token><analysis lemma="..." tag="..."/><analysis...>...</token>``
  element to encode morphological analysis.

  Example output for input ``Děti pojedou k babičce. Už se těší.`` (line breaks added):
```
<sentence><token><analysis lemma="dítě" tag="NNFP1-----A----"/><analysis lemma="dítě" tag="NNFP4-----A----"/><analysis lemma="dítě" tag="NNFP5-----A----"/>Děti</token>
<token><analysis lemma="jet-1_^(pohybovat_se,_ne_však_chůzí)" tag="VB-P---3F-AA---"/>pojedou</token>
<token><analysis lemma="k-1" tag="RR--3----------"/><analysis lemma="k-3_^(označení_pomocí_písmene)" tag="NNNXX-----A----"/><analysis lemma="k-4`kůň_:B_^(jednotka_výkonu)" tag="NNMXX-----A---8"/><analysis lemma="k-8_:B_^(ost._zkratka)" tag="XX------------8"/><analysis lemma="komanditní_:B_^(jen_komanditní_společnost)" tag="AAXXX----1A---8"/><analysis lemma="koncernový_:B" tag="AAXXX----1A---8"/><analysis lemma="kuo-1_:B_,t_^(stará_jednotka_výkonu)" tag="NNNXX-----A---8"/>k</token>
<token><analysis lemma="babička" tag="NNFS3-----A----"/><analysis lemma="babička" tag="NNFS6-----A----"/>babičce</token>
<token><analysis lemma="." tag="Z:-------------"/>.</token></sentence>
<sentence><token><analysis lemma="už-1" tag="Db-------------"/><analysis lemma="už-2" tag="TT-------------"/>Už</token>
<token><analysis lemma="se_^(zvr._zájmeno/částice)" tag="P7-X4----------"/><analysis lemma="s-1" tag="RV--2----------"/><analysis lemma="s-1" tag="RV--7----------"/>se</token>
<token><analysis lemma="těšit_:T" tag="VB-P---3P-AA---"/><analysis lemma="těšit_:T" tag="VB-S---3P-AA---"/>těší</token>
<token><analysis lemma="." tag="Z:-------------"/>.</token></sentence>
```

- ``vertical``: Every output line contains a word and a tab separated lemma-tag
  pairs assigned to the input word, with empty line denoting end of sentence.

  Example output for input ``Děti pojedou k babičce. Už se těší.``:
```
Děti	dítě	NNFP1-----A----	dítě	NNFP4-----A----	dítě	NNFP5-----A----
pojedou	jet-1_^(pohybovat_se,_ne_však_chůzí)	VB-P---3F-AA---
k	k-1	RR--3----------	k-3_^(označení_pomocí_písmene)	NNNXX-----A----	k-4`kůň_:B_^(jednotka_výkonu)	NNMXX-----A---8	k-8_:B_^(ost._zkratka)	XX------------8	komanditní_:B_^(jen_komanditní_společnost)	AAXXX----1A---8	koncernový_:B	AAXXX----1A---8	kuo-1_:B_,t_^(stará_jednotka_výkonu)	NNNXX-----A---8
babičce	babička	NNFS3-----A----	babička	NNFS6-----A----
.	.	Z:-------------

Už	už-1	Db-------------	už-2	TT-------------
se	se_^(zvr._zájmeno/částice)	P7-X4----------	s-1	RV--2----------	s-1	RV--7----------
těší	těšit_:T	VB-P---3P-AA---	těšit_:T	VB-S---3P-AA---
.	.	Z:-------------
```


=== Morphological Generation ===[run_morpho_generate]

The morphological generation can be performed by running
``` run_morpho_generate morphology_model use_guesser

The input is assumed to be in UTF-8 encoding. The input files are specified
same as with the [``run_tagger`` #run_tagger] command.

Input for morphological generation has to be in vertical format, each line
containing a lemma, which can be optionally followed by a tab and a
[tag wildcard #tag_wildcard]. The output has the same number of lines as input,
line //l// contains tab separated form-lemma-tag triplets which can be generated
from the lemma on he input line //l//. If a tag wildcard was provided, only
triplets with matching tags are returned.

Some morphological models contain both a manually created dictionary and
a guesser. Therefore, a numeric ``use_guesser`` argument is required.
If non-zero, the guesser is used, otherwise not.

The full command syntax of ``run_morpho_generate`` is
```
run_morpho_generate [options] morphology_model use_guesser [input_file[:output_file]]...
Options: --convert_tagset=pdt_to_conll2009
```

Example input data:
```
dítě
jet	?[fN]??[-1]
k-1
babička	NNFS3-----A----
```

Example output:
```
dítě	dítě	NNNS1-----A----	dítě	dítě	NNNS4-----A----	dítě	dítě	NNNS5-----A----	dítěte	dítě	NNNS2-----A----	dítěti	dítě	NNNS3-----A----	dítěti	dítě	NNNS6-----A----	dítětem	dítě	NNNS7-----A----	děti	dítě	NNFP1-----A----	děti	dítě	NNFP4-----A----	děti	dítě	NNFP5-----A----	dětma	dítě	NNFP7-----A---6	dětmi	dítě	NNFP7-----A----	dětem	dítě	NNFP3-----A----	dětí	dítě	NNFP2-----A----	dětech	dítě	NNFP6-----A----	dětima	dítě_,h	NNFP7-----A---6
ject	jet	Vf--------A---6	jet	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------A----	jeti	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------A---2	nejet	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------N----	nejeti	jet-1_^(pohybovat_se,_ne_však_chůzí)	Vf--------N---2	jet	jet-2_,h_^(letadlo_s_tryskovým_pohonem)NNIS1-----A----	jety	jet-2_,h_^(letadlo_s_tryskovým_pohonem)	NNIP1-----A----
k	k-1	RR--3----------	ke	k-1	RV--3----------	ku	k-1	RV--3---------1
babičce babička NNFS3-----A----
```

==== Tag Set Conversion ====

Some tag sets can be converted to different ones. Currently supported tag set
conversions are:
- ``pdt_to_conll2009``: convert Czech PDT tag set to CoNLL 2009 tag set.


Note that the tag set conversion is applied only to the output, not to the
input lemmas and wildcards.


==== Tag Wildcards ====[tag_wildcard]

When only forms with a specific tag should be generated for a given lemma, tag
wildcard can be specified. The tag wildcard is a simple wildcard allowing to filter
the results of morphological generation.

Most characters of a tag wildcard match corresponding characters of a tag, with the following exceptions:
 - ``?`` matches any character of a tag.
 - ``[chars]`` matches any of the characters listed. The dash ``-`` has no special meaning and if ``]``
   is the first character in ``chars``, it is considered as one of the characters and does not end the group.
 - ``[^chars]`` matches any of the characters //not// listed.


=== Interactive Morphological Analysis and Generation ===[run_morpho_cli]


Morphological analysis and generation which is interactive and more human readable
can be run using:
``` run_morpho_cli morphology_model

The input is read from standard input, command on each line. If there is no space
on a line, analysis is performed on the given word. Otherwise generation is performed
on the first word, using the rest of the line as a [tag wildcard #tag_wildcard].
If the second word is empty (i.e., the input is for example ``on ``), all forms
are generated.

== Running the Tokenizer ==[run_tokenizer]

Using the ``run_tokenizer`` executable it is possible to perform only
tokenization and segmentation.

The input is a UTF-8 encoded plain text and the input files are specified same
as with the [``run_tagger`` #run_tagger] command.

The tokenizer can be specified either by using a morphology model
(``--morphology`` option), tagger model (``--tagger`` option) or by using
a tokenizer identifier (``--tokenizer`` option). Currently supported
tokenizer identifiers are:
- ``czech``
- ``english``
- ``generic``


The full command syntax of ``run_tokenizer`` is
```
run_tokenizer [options] [file[:output_file]]...
Options: --tokenizer=czech|english|generic
         --morphology=morphology_model_file
         --tagger=tagger_model_file
         --output=vertical|xml
```

=== Output Formats ===

The output format is specified using the ``--output`` option. Currently
supported output formats are:
- ``xml`` (default): Simple XML format without a root element, using
  ``<sentence>`` element to mark sentences and ``<token>`` element to mark
  tokens.

  Example output for input ``Děti pojedou k babičce. Už se těší.`` (line breaks added):
```
<sentence><token>Děti</token> <token>pojedou</token> <token>k</token>
<token>babičce</token><token>.</token></sentence> <sentence><token>Už</token>
<token>se</token> <token>těší</token><token>.</token></sentence>
```

- ``vertical``: Each token is on a separate line, every sentence is ended by
  a blank line.

  Example output for input ``Děti pojedou k babičce. Už se těší.``:
```
Děti
pojedou
k
babičce
.

Už
se
těší
.

```
